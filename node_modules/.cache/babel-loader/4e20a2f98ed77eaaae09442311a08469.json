{"ast":null,"code":"import { __assign, __spreadArray } from 'tslib';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_OPTIONS = {\n  includeMetadataChanges: false\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction _fromRef(ref, options) {\n  if (options === void 0) {\n    options = DEFAULT_OPTIONS;\n  }\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return new Observable(function (subscriber) {\n    var unsubscribe = ref.onSnapshot(options, {\n      next: subscriber.next.bind(subscriber),\n      error: subscriber.error.bind(subscriber),\n      complete: subscriber.complete.bind(subscriber)\n    });\n    return {\n      unsubscribe: unsubscribe\n    };\n  });\n}\nfunction fromRef(ref, options) {\n  return _fromRef(ref, options);\n}\nfunction fromDocRef(ref, options) {\n  return fromRef(ref, options);\n}\nfunction fromCollectionRef(ref, options) {\n  return fromRef(ref, options);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction doc(ref) {\n  return fromDocRef(ref, {\n    includeMetadataChanges: true\n  });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nfunction docData(ref, idField) {\n  return doc(ref).pipe(map(function (snap) {\n    return snapToData(snap, idField);\n  }));\n}\nfunction snapToData(snapshot, idField) {\n  var _a;\n  // match the behavior of the JS SDK when the snapshot doesn't exist\n  if (!snapshot.exists) {\n    return snapshot.data();\n  }\n  return __assign(__assign({}, snapshot.data()), idField ? (_a = {}, _a[idField] = snapshot.id, _a) : null);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nvar filterEvents = function (events) {\n  return filter(function (changes) {\n    var hasChange = false;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n    return hasChange;\n  });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n  var args = [];\n  for (var _i = 3; _i < arguments.length; _i++) {\n    args[_i - 3] = arguments[_i];\n  }\n  var returnArray = original.slice();\n  returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) ;else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(current, changes, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n  changes.forEach(function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\nvar windowwise = function () {\n  return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\nvar metaDataEquals = function (a, b) {\n  return JSON.stringify(a.metadata) === JSON.stringify(b.metadata);\n};\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nvar filterEmptyUnlessFirst = function () {\n  return pipe(windowwise(), filter(function (_a) {\n    var prior = _a[0],\n      current = _a[1];\n    return current.length > 0 || prior === undefined;\n  }), map(function (_a) {\n    _a[0];\n    var current = _a[1];\n    return current;\n  }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nfunction collectionChanges(query, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n  return fromCollectionRef(query, {\n    includeMetadataChanges: true\n  }).pipe(windowwise(), map(function (_a) {\n    var priorSnapshot = _a[0],\n      currentSnapshot = _a[1];\n    var docChanges = currentSnapshot.docChanges();\n    if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n      // the metadata has changed, docChanges() doesn't return metadata events, so let's\n      // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n      // since either this docChanges() emission or the prior snapshot\n      currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n        var currentDocChange = docChanges.find(function (c) {\n          return c.doc.ref.isEqual(currentDocSnapshot.ref);\n        });\n        if (currentDocChange) {\n          // if the doc is in the current changes and the metadata hasn't changed this doc\n          if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n            return;\n          }\n        } else {\n          // if there is a prior doc and the metadata hasn't changed skip this doc\n          var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n            return d.ref.isEqual(currentDocSnapshot.ref);\n          });\n          if (priorDocSnapshot && metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n            return;\n          }\n        }\n        docChanges.push({\n          oldIndex: currentIndex,\n          newIndex: currentIndex,\n          type: 'modified',\n          doc: currentDocSnapshot\n        });\n      });\n    }\n    return docChanges;\n  }), filterEvents(events), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nfunction collection(query) {\n  return fromCollectionRef(query, {\n    includeMetadataChanges: true\n  }).pipe(map(function (changes) {\n    return changes.docs;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nfunction sortedChanges(query, events) {\n  return collectionChanges(query, events).pipe(scan(function (current, changes) {\n    return processDocumentChanges(current, changes, events);\n  }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nfunction auditTrail(query, events) {\n  return collectionChanges(query, events).pipe(scan(function (current, action) {\n    return __spreadArray(__spreadArray([], current), action);\n  }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nfunction collectionData(query, idField) {\n  return collection(query).pipe(map(function (arr) {\n    return arr.map(function (snap) {\n      return snapToData(snap, idField);\n    });\n  }));\n}\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromCollectionRef, fromDocRef, fromRef, snapToData, sortedChanges };","map":{"version":3,"sources":["../../firestore/fromRef.ts","../../firestore/document/index.ts","../../firestore/collection/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Observable } from 'rxjs';\nvar DEFAULT_OPTIONS = { includeMetadataChanges: false };\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction _fromRef(ref, options) {\n    if (options === void 0) { options = DEFAULT_OPTIONS; }\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return new Observable(function (subscriber) {\n        var unsubscribe = ref.onSnapshot(options, {\n            next: subscriber.next.bind(subscriber),\n            error: subscriber.error.bind(subscriber),\n            complete: subscriber.complete.bind(subscriber),\n        });\n        return { unsubscribe: unsubscribe };\n    });\n}\nexport function fromRef(ref, options) {\n    return _fromRef(ref, options);\n}\nexport function fromDocRef(ref, options) {\n    return fromRef(ref, options);\n}\nexport function fromCollectionRef(ref, options) {\n    return fromRef(ref, options);\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport { fromDocRef } from '../fromRef';\nimport { map } from 'rxjs/operators';\nexport function doc(ref) {\n    return fromDocRef(ref, { includeMetadataChanges: true });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nexport function docData(ref, idField) {\n    return doc(ref).pipe(map(function (snap) { return snapToData(snap, idField); }));\n}\nexport function snapToData(snapshot, idField) {\n    var _a;\n    // match the behavior of the JS SDK when the snapshot doesn't exist\n    if (!snapshot.exists) {\n        return snapshot.data();\n    }\n    return __assign(__assign({}, snapshot.data()), (idField ? (_a = {}, _a[idField] = snapshot.id, _a) : null));\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __spreadArray } from \"tslib\";\nimport { fromCollectionRef } from '../fromRef';\nimport { pipe } from 'rxjs';\nimport { map, filter, scan, distinctUntilChanged, startWith, pairwise } from 'rxjs/operators';\nimport { snapToData } from '../document';\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nvar filterEvents = function (events) {\n    return filter(function (changes) {\n        var hasChange = false;\n        for (var i = 0; i < changes.length; i++) {\n            var change = changes[i];\n            if (events && events.indexOf(change.type) >= 0) {\n                hasChange = true;\n                break;\n            }\n        }\n        return hasChange;\n    });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        args[_i - 3] = arguments[_i];\n    }\n    var returnArray = original.slice();\n    returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n    return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] &&\n                combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n                // Skip duplicate emissions. This is rare.\n                // TODO: Investigate possible bug in SDK.\n            }\n            else {\n                return sliceAndSplice(combined, change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null ||\n                combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    var copiedArray = combined.slice();\n                    copiedArray.splice(change.oldIndex, 1);\n                    copiedArray.splice(change.newIndex, 0, change);\n                    return copiedArray;\n                }\n                else {\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] &&\n                combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                return sliceAndSplice(combined, change.oldIndex, 1);\n            }\n            break;\n        default: // ignore\n    }\n    return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(current, changes, events) {\n    if (events === void 0) { events = ALL_EVENTS; }\n    changes.forEach(function (change) {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = processIndividualChange(current, change);\n        }\n    });\n    return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\nvar windowwise = function () {\n    return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\nvar metaDataEquals = function (a, b) { return JSON.stringify(a.metadata) === JSON.stringify(b.metadata); };\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nvar filterEmptyUnlessFirst = function () {\n    return pipe(windowwise(), filter(function (_a) {\n        var prior = _a[0], current = _a[1];\n        return current.length > 0 || prior === undefined;\n    }), map(function (_a) {\n        var _ = _a[0], current = _a[1];\n        return current;\n    }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function collectionChanges(query, events) {\n    if (events === void 0) { events = ALL_EVENTS; }\n    return fromCollectionRef(query, { includeMetadataChanges: true }).pipe(windowwise(), map(function (_a) {\n        var priorSnapshot = _a[0], currentSnapshot = _a[1];\n        var docChanges = currentSnapshot.docChanges();\n        if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n            // the metadata has changed, docChanges() doesn't return metadata events, so let's\n            // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n            // since either this docChanges() emission or the prior snapshot\n            currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n                var currentDocChange = docChanges.find(function (c) {\n                    return c.doc.ref.isEqual(currentDocSnapshot.ref);\n                });\n                if (currentDocChange) {\n                    // if the doc is in the current changes and the metadata hasn't changed this doc\n                    if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                else {\n                    // if there is a prior doc and the metadata hasn't changed skip this doc\n                    var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n                        return d.ref.isEqual(currentDocSnapshot.ref);\n                    });\n                    if (priorDocSnapshot &&\n                        metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                docChanges.push({\n                    oldIndex: currentIndex,\n                    newIndex: currentIndex,\n                    type: 'modified',\n                    doc: currentDocSnapshot\n                });\n            });\n        }\n        return docChanges;\n    }), filterEvents(events), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nexport function collection(query) {\n    return fromCollectionRef(query, { includeMetadataChanges: true }).pipe(map(function (changes) { return changes.docs; }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges(query, events) {\n    return collectionChanges(query, events).pipe(scan(function (current, changes) {\n        return processDocumentChanges(current, changes, events);\n    }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nexport function auditTrail(query, events) {\n    return collectionChanges(query, events).pipe(scan(function (current, action) { return __spreadArray(__spreadArray([], current), action); }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nexport function collectionData(query, idField) {\n    return collection(query).pipe(map(function (arr) {\n        return arr.map(function (snap) { return snapToData(snap, idField); });\n    }));\n}\n"]},"metadata":{},"sourceType":"module"}