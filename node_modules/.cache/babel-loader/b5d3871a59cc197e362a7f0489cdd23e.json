{"ast":null,"code":"import { __values } from \"tslib\";\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function bufferTime(bufferTimeSpan) {\n  var _a, _b;\n  var otherArgs = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    otherArgs[_i - 1] = arguments[_i];\n  }\n  var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;\n  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n  var maxBufferSize = otherArgs[1] || Infinity;\n  return operate(function (source, subscriber) {\n    var bufferRecords = [];\n    var restartOnEmit = false;\n    var emit = function (record) {\n      var buffer = record.buffer,\n        subs = record.subs;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n    var startBuffer = function () {\n      if (bufferRecords) {\n        var subs = new Subscription();\n        subscriber.add(subs);\n        var buffer = [];\n        var record_1 = {\n          buffer: buffer,\n          subs: subs\n        };\n        bufferRecords.push(record_1);\n        executeSchedule(subs, scheduler, function () {\n          return emit(record_1);\n        }, bufferTimeSpan);\n      }\n    };\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n    startBuffer();\n    var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function (value) {\n      var e_1, _a;\n      var recordsCopy = bufferRecords.slice();\n      try {\n        for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {\n          var record = recordsCopy_1_1.value;\n          var buffer = record.buffer;\n          buffer.push(value);\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }, function () {\n      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n        subscriber.next(bufferRecords.shift().buffer);\n      }\n      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n      subscriber.complete();\n      subscriber.unsubscribe();\n    }, undefined, function () {\n      return bufferRecords = null;\n    });\n    source.subscribe(bufferTimeSubscriber);\n  });\n}","map":{"version":3,"sources":["../../../../src/internal/operators/bufferTime.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __values } from \"tslib\";\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function bufferTime(bufferTimeSpan) {\n    var _a, _b;\n    var otherArgs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        otherArgs[_i - 1] = arguments[_i];\n    }\n    var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;\n    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n    var maxBufferSize = otherArgs[1] || Infinity;\n    return operate(function (source, subscriber) {\n        var bufferRecords = [];\n        var restartOnEmit = false;\n        var emit = function (record) {\n            var buffer = record.buffer, subs = record.subs;\n            subs.unsubscribe();\n            arrRemove(bufferRecords, record);\n            subscriber.next(buffer);\n            restartOnEmit && startBuffer();\n        };\n        var startBuffer = function () {\n            if (bufferRecords) {\n                var subs = new Subscription();\n                subscriber.add(subs);\n                var buffer = [];\n                var record_1 = {\n                    buffer: buffer,\n                    subs: subs,\n                };\n                bufferRecords.push(record_1);\n                executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);\n            }\n        };\n        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n            executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n        }\n        else {\n            restartOnEmit = true;\n        }\n        startBuffer();\n        var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function (value) {\n            var e_1, _a;\n            var recordsCopy = bufferRecords.slice();\n            try {\n                for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {\n                    var record = recordsCopy_1_1.value;\n                    var buffer = record.buffer;\n                    buffer.push(value);\n                    maxBufferSize <= buffer.length && emit(record);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }, function () {\n            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n                subscriber.next(bufferRecords.shift().buffer);\n            }\n            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n            subscriber.complete();\n            subscriber.unsubscribe();\n        }, undefined, function () { return (bufferRecords = null); });\n        source.subscribe(bufferTimeSubscriber);\n    });\n}\n//# sourceMappingURL=bufferTime.js.map"]},"metadata":{},"sourceType":"module"}