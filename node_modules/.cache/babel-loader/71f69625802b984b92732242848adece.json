{"ast":null,"code":"import { Observable, from } from 'rxjs';\nimport { debounceTime, shareReplay, map } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction fromTask(task) {\n  return new Observable(function (subscriber) {\n    var progress = function (snap) {\n      return subscriber.next(snap);\n    };\n    var error = function (e) {\n      return subscriber.error(e);\n    };\n    var complete = function () {\n      return subscriber.complete();\n    };\n    // emit the current state of the task\n    progress(task.snapshot);\n    // emit progression of the task\n    var unsubscribeFromOnStateChanged = task.on('state_changed', progress);\n    // use the promise form of task, to get the last success snapshot\n    task.then(function (snapshot) {\n      progress(snapshot);\n      setTimeout(function () {\n        return complete();\n      }, 0);\n    }, function (e) {\n      progress(task.snapshot);\n      setTimeout(function () {\n        return error(e);\n      }, 0);\n    });\n    // the unsubscribe method returns by storage isn't typed in the\n    // way rxjs expects, Function vs () => void, so wrap it\n    return function unsubscribe() {\n      unsubscribeFromOnStateChanged();\n    };\n  }).pipe(\n  // since we're emitting first the current snapshot and then progression\n  // it's possible that we could double fire synchronously; namely when in\n  // a terminal state (success, error, canceled). Debounce to address.\n  debounceTime(0));\n}\nfunction getDownloadURL(ref) {\n  return from(ref.getDownloadURL());\n}\n// TODO: fix storage typing in firebase, then apply the same fix here\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getMetadata(ref) {\n  return from(ref.getMetadata());\n}\nfunction put(ref, data, metadata) {\n  return new Observable(function (subscriber) {\n    var task = ref.put(data, metadata);\n    return fromTask(task).subscribe(subscriber).add(task.cancel);\n  }).pipe(shareReplay({\n    bufferSize: 1,\n    refCount: true\n  }));\n}\nfunction putString(ref, data, format, metadata) {\n  return new Observable(function (subscriber) {\n    var task = ref.putString(data, format, metadata);\n    return fromTask(task).subscribe(subscriber).add(task.cancel);\n  }).pipe(shareReplay({\n    bufferSize: 1,\n    refCount: true\n  }));\n}\nfunction percentage(task) {\n  return fromTask(task).pipe(map(function (s) {\n    return {\n      progress: s.bytesTransferred / s.totalBytes * 100,\n      snapshot: s\n    };\n  }));\n}\nexport { fromTask, getDownloadURL, getMetadata, percentage, put, putString };","map":{"version":3,"sources":["../../storage/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Observable, from } from 'rxjs';\nimport { debounceTime, map, shareReplay } from 'rxjs/operators';\nexport function fromTask(task) {\n    return new Observable(function (subscriber) {\n        var progress = function (snap) { return subscriber.next(snap); };\n        var error = function (e) { return subscriber.error(e); };\n        var complete = function () { return subscriber.complete(); };\n        // emit the current state of the task\n        progress(task.snapshot);\n        // emit progression of the task\n        var unsubscribeFromOnStateChanged = task.on('state_changed', progress);\n        // use the promise form of task, to get the last success snapshot\n        task.then(function (snapshot) {\n            progress(snapshot);\n            setTimeout(function () { return complete(); }, 0);\n        }, function (e) {\n            progress(task.snapshot);\n            setTimeout(function () { return error(e); }, 0);\n        });\n        // the unsubscribe method returns by storage isn't typed in the\n        // way rxjs expects, Function vs () => void, so wrap it\n        return function unsubscribe() {\n            unsubscribeFromOnStateChanged();\n        };\n    }).pipe(\n    // since we're emitting first the current snapshot and then progression\n    // it's possible that we could double fire synchronously; namely when in\n    // a terminal state (success, error, canceled). Debounce to address.\n    debounceTime(0));\n}\nexport function getDownloadURL(ref) {\n    return from(ref.getDownloadURL());\n}\n// TODO: fix storage typing in firebase, then apply the same fix here\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getMetadata(ref) {\n    return from(ref.getMetadata());\n}\nexport function put(ref, data, metadata) {\n    return new Observable(function (subscriber) {\n        var task = ref.put(data, metadata);\n        return fromTask(task).subscribe(subscriber).add(task.cancel);\n    }).pipe(shareReplay({ bufferSize: 1, refCount: true }));\n}\nexport function putString(ref, data, format, metadata) {\n    return new Observable(function (subscriber) {\n        var task = ref.putString(data, format, metadata);\n        return fromTask(task).subscribe(subscriber).add(task.cancel);\n    }).pipe(shareReplay({ bufferSize: 1, refCount: true }));\n}\nexport function percentage(task) {\n    return fromTask(task).pipe(map(function (s) { return ({\n        progress: (s.bytesTransferred / s.totalBytes) * 100,\n        snapshot: s\n    }); }));\n}\n"]},"metadata":{},"sourceType":"module"}